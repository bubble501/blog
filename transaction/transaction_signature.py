from past_modules import *
from initial_parameter import *
#=====================================================================================================
#reration to "ecdsa_tx_sign"

#DER encoded signature
def der_encode_sig(v, r, s):
    #signature(r, s), header byte(v)
    b1 = str(binascii.hexlify(encode(r, 256)), 'utf-8')
    b2 = str(binascii.hexlify(encode(s, 256)), 'utf-8')
    left = '02'+encode(len(b1)//2, 16, 2)+b1
    right = '02'+encode(len(b2)//2, 16, 2)+b2
    return '30'+encode(len(left+right)//2, 16, 2)+left+right

#RFC 6979
def deterministic_generate_k(msghash, priv):
    #Byte sequence(v) generate from setting "0x01" of 32-byte
    #Byte sequence(k) generate from setting "0x00" of 32-byte
    v = b'\x01' * 32
    k = b'\x00' * 32
    #coverte to bin
    priv = encode_privkey(priv, 'bin')
    #tx data converte to int and encode 256hex
    msghash = encode(hash_to_int(msghash), 256, 32)
    # K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1))
    k = hmac.new(k, v+b'\x00'+priv+msghash, hashlib.sha256).digest()
    #V = HMAC_K(V)
    v = hmac.new(k, v, hashlib.sha256).digest()
    #K = HMAC_K(V || 0x01 || int2octets(x) || bits2octets(h1))
    k = hmac.new(k, v+b'\x01'+priv+msghash, hashlib.sha256).digest()
    #V = HMAC_K(V)
    v = hmac.new(k, v, hashlib.sha256).digest()
    #V = HMAC_K(V)
    return decode(hmac.new(k, v, hashlib.sha256).digest(), 256)

#raw signature
def ecdsa_raw_sign(msghash, priv):
    z = hash_to_int(msghash)
    #Deterministic Usage of the DSA(RFC 6979)
    k = deterministic_generate_k(msghash, priv)
    #ECDSA
    #Point R
    #r * G = R =(xU, yU)
    #u = xU(mod l)
    r, y = fast_multiply(G, k)
    #v = (H + u * d) / r　( mod l)
    s = (z + r*decode_privkey(priv)) * inv(k, N) % N
    #even get v = 27, odd get v = 28.
    v = 27+((y % 2) ^ (0 if s * 2 < N else 1))
    #In the case of Bitcoin,　Within N
    s = s if s * 2 < N else N - s
    #signatre value(r,s)
    #header byte(v)
    return v, r, s

#convert bytecode to 256hex(64byte)
def txhash(tx, hashcode=None):
    if isinstance(tx, str):
        tx = changebase(tx, 16, 256)   
    return dbl_sha256(from_string_to_bytes(tx) + encode(int(hashcode), 256, 4)[::-1])

#signature generate using ecdsa from tx and privkey
def ecdsa_tx_sign(tx, priv, hashcode=SIGHASH_ALL):
    rawsig = ecdsa_raw_sign(binascii.unhexlify(txhash(tx, hashcode)), priv)
    return der_encode_sig(*rawsig)+encode(hashcode, 16, 2)
                                          
#=====================================================================================================
#reration to "signature_form"
 
#Add scriptPubkey(input) + previous output index for tx
def signature_form(tx, i, script, hashcode=SIGHASH_ALL):
    i = int(i)
    hashcode = int(hashcode)
    #string_or_bytes_types = (str, bytes)
    if isinstance(tx, string_or_bytes_types):
        return serialize(signature_form(deserialize(tx), i, script, hashcode)) 
    for inp in tx["ins"]:
        inp["script"] = ""
    tx["ins"][i]["script"] = script
    return tx    
#===================================================================================================== 
def serialize_script_unit(unit):
    return bytes([len(unit)])+unit

def serialize_script(script):
        if json_is_base(script, 16):
            a = serialize_script(json_changebase(script,lambda x: binascii.unhexlify(x)))
            return str(binascii.hexlify(a), 'utf-8')
        result = bytes()
        for b in map(serialize_script_unit, script):
            result += b
        return result

#main function
def sign(tx, i, priv, hashcode=SIGHASH_ALL):
    #generate address from privkey
    pub = privkey_to_pubkey(priv)
    address = pubkey_to_address(pub)
    #temporary staging to Public key hash
    signing_tx = signature_form(tx, int(i), '76a914' + b58check_to_hex(address) + '88ac', hashcode)
    #signature is generated by ECDSA
    sig = ecdsa_tx_sign(signing_tx, priv, hashcode)
    #convert to easily seen about tx
    txobj = deserialize(tx)
    #txobj add signature value and public key
    txobj["ins"][int(i)]["script"] = serialize_script([sig, pub])
    return serialize(txobj)
#=====================================================================================================
priv   = "57c617d9b4e1f7af6ec97ca2ff57e94a28279a7eedd4d12a99fa11170e94f5a4"
tx     = "0100000003b3822a498733330f9306fb10071bab2eec9b8e670a10530db2994018e5d2aab00000000000ffffffff71d1abe4352100d4d837ca96c1a16947b5444f0f3e0bc645c430f704bb06c84c0100000000ffffffff5e46552eb977f908fa8b3ee9d2943a8fa6d96c3b768a5f250ce485acd8c7f7970000000000ffffffff01905f0100000000001976a9143ec6c3ed8dfc3ceabcc1cbdb0c5aef4e2d02873c88ac00000000"

tx2 = sign(tx,0,priv)
tx3 = sign(tx2,1,priv)
tx3